{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Конфигурация
    const config = {
        startHour: 0,
        endHour: 24,
        slotMinutes: 15,
        slotHeight: 25
    };

    // Вспомогательные функции для работы с временем
    function roundToNearest15Minutes(date, roundType = 'round') {
        const minutes = date.getMinutes();
        let roundedMinutes;
        
        if (roundType === 'ceil') {
            roundedMinutes = Math.ceil(minutes / 15) * 15;
        } else if (roundType === 'floor') {
            roundedMinutes = Math.floor(minutes / 15) * 15;
        } else {
            roundedMinutes = Math.round(minutes / 15) * 15;
        }
        
        const newDate = new Date(date);
        
        if (roundedMinutes === 60) {
            newDate.setHours(newDate.getHours() + 1);
            newDate.setMinutes(0);
        } else {
            newDate.setMinutes(roundedMinutes);
        }
        
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
        return newDate;
    }
    
    function formatTimeForAPI(date) {
        // Формат для API: '2024-01-01 14:30:00'
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:00`;
    }
    
    function parseTimeFromAPI(timeString) {
        // Преобразуем '2024-01-01 14:30:00' в Date
        return new Date(timeString.replace(' ', 'T') + 'Z');
    }

    // Состояние приложения
    const state = {
        selectedCells: new Set(),
        categories: [],
        events: [],
        templates: [],
        isCtrlPressed: false,
        isShiftPressed: false,
        lastSelectedCell: null,
        timeSettings: {
            startHour: 0,
            endHour: 24
        }
    };

    // Элементы DOM
    const elements = {
        scheduleBody: document.getElementById('scheduleBody'),
        scheduleTable: document.getElementById('scheduleTable'),
        weekPicker: document.getElementById('weekPicker'),
        weekRange: document.getElementById('weekRange'),
        currentWeekBtn: document.getElementById('currentWeekBtn'),
        prevWeekBtn: document.getElementById('prevWeekBtn'),
        nextWeekBtn: document.getElementById('nextWeekBtn'),
        saveTemplateBtn: document.getElementById('saveTemplateBtn'),
        templatesBtn: document.getElementById('templatesBtn'),
        addCategoryBtn: document.getElementById('addCategoryBtn'),
        bulkEditPanel: document.getElementById('bulkEditPanel'),
        selectedCount: document.getElementById('selectedCount'),
        bulkCategorySelect: document.getElementById('bulkCategorySelect'),
        bulkPlanBtn: document.getElementById('bulkPlanBtn'),
        bulkFactBtn: document.getElementById('bulkFactBtn'),
        bulkClearBtn: document.getElementById('bulkClearBtn'),
        bulkCancelBtn: document.getElementById('bulkCancelBtn'),
        categoriesList: document.getElementById('categoriesList'),
        categorySelect: document.getElementById('categorySelect'),
        quickCategory: document.getElementById('quickCategory'),
        balanceWheel: document.getElementById('balanceWheel'),
        wheelPeriod: document.getElementById('wheelPeriod'),
        wheelLegend: document.getElementById('wheelLegend'),
        quickEventBtn: document.getElementById('quickEventBtn'),
        clearDayBtn: document.getElementById('clearDayBtn'),
        copyDayBtn: document.getElementById('copyDayBtn'),
        statsBtn: document.getElementById('statsBtn'),
        addPlanBtn: document.getElementById('addPlanBtn'),
        addFactBtn: document.getElementById('addFactBtn')
    };

    // Инициализация
    init();
    
    async function init() {
        initSchedule();
        initTimeSelects();
        await loadCategories();
        await loadEvents();
        await loadTemplates();
        initEventHandlers();
        initCurrentTimeIndicator();
        updateWeekRange();
    }
    
    // Раздел 1.1: Двухколоночная структура дня
    function initSchedule() {
        elements.scheduleBody.innerHTML = '';
        
        const startHour = parseFloat(state.timeSettings.startHour);
        const endHour = parseFloat(state.timeSettings.endHour);
        
        for (let hour = startHour; hour < endHour; hour += config.slotMinutes / 60) {
            const hourInt = Math.floor(hour);
            const minute = (hour - hourInt) * 60;
            const timeString = `${hourInt.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            const isHourMark = minute === 0;
            
            const row = document.createElement('tr');
            row.className = 'time-slot-row';
            if (isHourMark) row.classList.add('hour-marker');
            
            // Колонка времени
            const timeCell = document.createElement('td');
            timeCell.className = 'time-column';
            timeCell.textContent = timeString;
            row.appendChild(timeCell);
            
            // Колонки для каждого дня
            for (let day = 0; day < 7; day++) {
                const planCell = document.createElement('td');
                planCell.className = 'plan-column';
                planCell.dataset.time = timeString;
                planCell.dataset.day = day;
                planCell.dataset.type = 'plan';
                planCell.dataset.id = `${day}-${timeString}-plan`;
                
                const factCell = document.createElement('td');
                factCell.className = 'fact-column';
                factCell.dataset.time = timeString;
                factCell.dataset.day = day;
                factCell.dataset.type = 'fact';
                factCell.dataset.id = `${day}-${timeString}-fact`;
                
                row.appendChild(planCell);
                row.appendChild(factCell);
            }
            
            elements.scheduleBody.appendChild(row);
        }
        
        updateCurrentTimeHighlight();
    }
    
    // Раздел 1.4: Обработка кликов по ячейкам
    function initSelectionHandlers() {
        elements.scheduleTable.addEventListener('click', handleCellClick);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
    }
    
    function handleCellClick(event) {
        const cell = event.target.closest('.plan-column, .fact-column');
        if (!cell) return;
        
        // Если кликнули на событие, редактируем его
        if (event.target.classList.contains('plan-event') || 
            event.target.classList.contains('fact-event')) {
            editEvent(event.target.dataset.eventId);
            return;
        }
        
        // Иначе создаем новое событие
        const day = parseInt(cell.dataset.day);
        const time = cell.dataset.time;
        const type = cell.dataset.type;
        
        // Определяем дату на основе выбранной недели
        const weekStart = getWeekStartDate();
        const eventDate = new Date(weekStart);
        eventDate.setDate(weekStart.getDate() + day);
        
        // Время начала события
        const [hours, minutes] = time.split(':').map(Number);
        const startTime = new Date(eventDate);
        startTime.setHours(hours, minutes, 0, 0);
        
        // Время окончания (+15 минут)
        const endTime = new Date(startTime);
        endTime.setMinutes(endTime.getMinutes() + 15);
        
        // Открываем форму
        openAddEventForm(type, {
            start: `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`,
            end: `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`,
            date: eventDate.toISOString().split('T')[0]
        });
    }
    
    // Раздел 1.3: Функционал работы с категориями
    async function loadCategories() {
        try {
            const response = await fetch('/api/v1/categories');
            if (response.ok) {
                const data = await response.json();
                state.categories = data;
                updateCategorySelects();
                updateCategoriesList();
            } else {
                console.error('Ошибка загрузки категорий:', response.status);
                loadDefaultCategories();
            }
        } catch (error) {
            console.error('Ошибка загрузки категорий:', error);
            loadDefaultCategories();
        }
    }
    
    function loadDefaultCategories() {
        state.categories = [
            { id: 1, name: 'Работа', color: '#f8b5d1', description: 'Рабочие задачи' },
            { id: 2, name: 'Учёба', color: '#cdb4db', description: 'Обучение и образование' },
            { id: 3, name: 'Спорт', color: '#a7d2cb', description: 'Физическая активность' },
            { id: 4, name: 'Отдых', color: '#ffd6e7', description: 'Время для отдыха' },
            { id: 5, name: 'Семья', color: '#ffafcc', description: 'Время с семьей' },
            { id: 6, name: 'Хобби', color: '#e2d4f0', description: 'Личные увлечения' }
        ];
        updateCategorySelects();
        updateCategoriesList();
    }
    
    function updateCategorySelects() {
        // Основной селект категорий
        elements.categorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        elements.bulkCategorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        elements.quickCategory.innerHTML = '<option value="">Выберите категорию</option>';
        
        state.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            option.style.color = category.color;
            elements.categorySelect.appendChild(option.cloneNode(true));
            elements.bulkCategorySelect.appendChild(option.cloneNode(true));
            elements.quickCategory.appendChild(option);
        });
    }
    
    // Загрузка событий
    async function loadEvents() {
        try {
            const [year, week] = elements.weekPicker.value.split('-W');
            const response = await fetch(`/api/events/week/${year}-W${week.padStart(2, '0')}`);
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    state.events = data.events || [];
                    renderEvents();
                    updateBalanceWheel();
                } else {
                    console.error('Ошибка загрузки событий:', data.error);
                }
            } else {
                console.error('Ошибка сети при загрузке событий:', response.status);
            }
        } catch (error) {
            console.error('Ошибка загрузки событий:', error);
        }
    }
    
    // СОХРАНЕНИЕ СОБЫТИЙ - ИСПРАВЛЕННАЯ ВЕРСИЯ
    async function saveEvent(eventData) {
        try {
            // Округляем время
            const startTime = roundToNearest15Minutes(new Date(eventData.start_time), 'floor');
            const endTime = roundToNearest15Minutes(new Date(eventData.end_time), 'ceil');
            
            // Форматируем для API
            const formattedEvent = {
                type: eventData.type,
                category_id: eventData.category_id,
                start_time: formatTimeForAPI(startTime),
                end_time: formatTimeForAPI(endTime),
                description: eventData.description || ''
            };
            
            console.log('Отправка события на сервер:', formattedEvent);
            
            const response = await fetch('/api/events', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formattedEvent)
            });
            
            const result = await response.json();
            console.log('Ответ от сервера:', result);
            
            if (result.success) {
                // Добавляем событие с ID от сервера
                const newEvent = {
                    id: result.event_id,
                    ...formattedEvent,
                    start_time: startTime.toISOString(),
                    end_time: endTime.toISOString()
                };
                
                state.events.push(newEvent);
                renderEvents();
                updateBalanceWheel();
                
                alert('Событие успешно сохранено!');
                return newEvent;
            } else {
                throw new Error(result.error || 'Неизвестная ошибка сервера');
            }
        } catch (error) {
            console.error('Ошибка сохранения события:', error);
            alert(`Не удалось сохранить событие: ${error.message}`);
            return null;
        }
    }
    
    // УДАЛЕНИЕ СОБЫТИЙ
    async function deleteEventById(eventId) {
        if (!confirm('Удалить это событие?')) return;
        
        try {
            const response = await fetch(`/api/events/${eventId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (result.success) {
                // Удаляем событие из состояния
                state.events = state.events.filter(e => e.id != eventId);
                
                renderEvents();
                updateBalanceWheel();
                
                alert('Событие удалено!');
                return true;
            } else {
                throw new Error(result.error || 'Ошибка удаления');
            }
        } catch (error) {
            console.error('Ошибка удаления события:', error);
            alert('Не удалось удалить событие');
            return false;
        }
    }
    
    // РЕДАКТИРОВАНИЕ СОБЫТИЙ
    async function editEvent(eventId) {
        const event = state.events.find(e => e.id == eventId);
        if (!event) {
            alert('Событие не найдено');
            return;
        }
        
        // Заполняем форму редактирования
        const startTime = new Date(event.start_time);
        const endTime = new Date(event.end_time);
        
        document.querySelector(`input[name="eventType"][value="${event.type}"]`).checked = true;
        document.getElementById('categorySelect').value = event.category_id;
        document.getElementById('startDate').value = startTime.toISOString().split('T')[0];
        document.getElementById('startTime').value = 
            `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
        document.getElementById('endDate').value = endTime.toISOString().split('T')[0];
        document.getElementById('endTime').value = 
            `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
        document.getElementById('eventDescription').value = event.description || '';
        
        // Меняем кнопку на "Обновить"
        const submitBtn = document.querySelector('#addEventForm button[type="submit"]');
        const originalText = submitBtn.textContent;
        submitBtn.textContent = 'Обновить событие';
        submitBtn.classList.remove('btn-primary');
        submitBtn.classList.add('btn-warning');
        
        // Добавляем кнопку удаления
        let deleteBtn = document.getElementById('deleteEventBtn');
        if (!deleteBtn) {
            deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'btn btn-danger';
            deleteBtn.id = 'deleteEventBtn';
            deleteBtn.innerHTML = '<i class="bi bi-trash me-2"></i>Удалить';
            deleteBtn.onclick = () => {
                deleteEventById(eventId).then(success => {
                    if (success) {
                        bootstrap.Modal.getInstance(document.getElementById('addEventModal')).hide();
                        resetEventForm();
                    }
                });
            };
            document.querySelector('#addEventForm .modal-footer').prepend(deleteBtn);
        }
        
        // Показываем модальное окно
        const modal = new bootstrap.Modal(document.getElementById('addEventModal'));
        modal.show();
        
        // Временный обработчик для обновления
        const originalSubmit = document.getElementById('addEventForm').onsubmit;
        
        document.getElementById('addEventForm').onsubmit = async function(e) {
            e.preventDefault();
            
            const updatedData = {
                type: document.querySelector('input[name="eventType"]:checked').value,
                category_id: parseInt(document.getElementById('categorySelect').value),
                start_time: `${document.getElementById('startDate').value} ${document.getElementById('startTime').value}:00`,
                end_time: `${document.getElementById('endDate').value} ${document.getElementById('endTime').value}:00`,
                description: document.getElementById('eventDescription').value
            };
            
            if (!updatedData.category_id) {
                alert('Выберите категорию');
                return;
            }
            
            try {
                // Обновляем событие через PUT запрос
                const response = await fetch(`/api/events/${eventId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatedData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Обновляем событие в состоянии
                    const index = state.events.findIndex(e => e.id == eventId);
                    if (index !== -1) {
                        state.events[index] = result.event || {
                            ...updatedData,
                            id: eventId
                        };
                    }
                    
                    renderEvents();
                    updateBalanceWheel();
                    
                    modal.hide();
                    resetEventForm();
                    alert('Событие обновлено!');
                } else {
                    throw new Error(result.error || 'Ошибка обновления');
                }
            } catch (error) {
                console.error('Ошибка обновления события:', error);
                alert('Не удалось обновить событие');
            }
        };
        
        // Функция сброса формы
        function resetEventForm() {
            document.getElementById('addEventForm').reset();
            submitBtn.textContent = originalText;
            submitBtn.classList.remove('btn-warning');
            submitBtn.classList.add('btn-primary');
            if (deleteBtn) deleteBtn.remove();
            document.getElementById('addEventForm').onsubmit = originalSubmit;
        }
    }
    
    // РЕНДЕРИНГ СОБЫТИЙ
    function renderEvents() {
        // Очищаем существующие события
        document.querySelectorAll('.plan-event, .fact-event').forEach(el => el.remove());
        
        state.events.forEach(event => {
            try {
                const start = new Date(event.start_time);
                const end = new Date(event.end_time);
                
                // Вычисляем позицию и длительность
                const startHour = start.getHours() + start.getMinutes() / 60;
                const endHour = end.getHours() + end.getMinutes() / 60;
                const durationSlots = Math.max(1, Math.round((endHour - startHour) * 4));
                const startSlot = Math.round((startHour - state.timeSettings.startHour) * 4);
                
                if (startSlot < 0 || startSlot >= elements.scheduleBody.children.length) {
                    console.warn('Событие вне диапазона:', event);
                    return;
                }
                
                // Определяем день недели
                const dayOfWeek = start.getDay();
                const adjustedDay = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                
                const row = elements.scheduleBody.children[startSlot];
                if (!row) return;
                
                // Индекс ячейки в строке: time-cell + (7 дней × 2 колонки)
                const planCellIndex = 1 + adjustedDay * 2;
                const factCellIndex = planCellIndex + 1;
                
                const targetCell = event.type === 'plan' ? 
                    row.children[planCellIndex] : 
                    row.children[factCellIndex];
                
                if (!targetCell) return;
                
                // Находим категорию
                const category = state.categories.find(c => c.id == event.category_id);
                const categoryName = category ? category.name : `Категория ${event.category_id}`;
                
                // Создаем элемент события
                const eventDiv = document.createElement('div');
                eventDiv.className = event.type === 'plan' ? 'plan-event' : 'fact-event';
                eventDiv.textContent = categoryName;
                eventDiv.title = event.description || categoryName;
                eventDiv.dataset.eventId = event.id;
                eventDiv.dataset.categoryId = event.category_id;
                
                if (category) {
                    eventDiv.style.borderLeftColor = category.color;
                }
                
                // Устанавливаем высоту для многослотовых событий
                if (durationSlots > 1) {
                    eventDiv.style.height = `${durationSlots * config.slotHeight - 2}px`;
                    eventDiv.style.top = '1px';
                }
                
                targetCell.appendChild(eventDiv);
                
            } catch (error) {
                console.error('Ошибка рендеринга события:', error, event);
            }
        });
    }
    
    // ОТКРЫТИЕ ФОРМЫ ДЛЯ ДОБАВЛЕНИЯ СОБЫТИЯ
    function openAddEventForm(type = 'plan', presetData = null) {
        // Сбрасываем форму
        document.getElementById('addEventForm').reset();
        
        // Устанавливаем тип события
        document.querySelector(`input[name="eventType"][value="${type}"]`).checked = true;
        
        if (presetData) {
            // Если переданы предустановленные данные
            document.getElementById('startDate').value = presetData.date;
            document.getElementById('startTime').value = presetData.start;
            document.getElementById('endDate').value = presetData.date;
            document.getElementById('endTime').value = presetData.end;
        } else {
            // Устанавливаем текущую дату и время
            const now = new Date();
            const todayStr = now.toISOString().split('T')[0];
            
            document.getElementById('startDate').value = todayStr;
            document.getElementById('endDate').value = todayStr;
            
            const startTime = roundToNearest15Minutes(now, 'floor');
            const endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            
            const startTimeStr = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
            const endTimeStr = `${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
            
            document.getElementById('startTime').value = startTimeStr;
            document.getElementById('endTime').value = endTimeStr;
        }
        
        // Фокусируемся на выборе категории
        setTimeout(() => {
            document.getElementById('categorySelect').focus();
        }, 100);
        
        // Показываем модальное окно
        const modal = new bootstrap.Modal(document.getElementById('addEventModal'));
        modal.show();
    }
    
    // ОБРАБОТЧИК ФОРМЫ ДОБАВЛЕНИЯ СОБЫТИЯ
    async function handleAddEventForm(e) {
        e.preventDefault();
        
        const eventData = {
            type: document.querySelector('input[name="eventType"]:checked').value,
            category_id: parseInt(document.getElementById('categorySelect').value),
            start_time: `${document.getElementById('startDate').value} ${document.getElementById('startTime').value}:00`,
            end_time: `${document.getElementById('endDate').value} ${document.getElementById('endTime').value}:00`,
            description: document.getElementById('eventDescription').value || ''
        };
        
        // Валидация
        if (!eventData.category_id) {
            alert('Выберите категорию');
            return;
        }
        
        const startDate = new Date(eventData.start_time.replace(' ', 'T'));
        const endDate = new Date(eventData.end_time.replace(' ', 'T'));
        
        if (endDate <= startDate) {
            alert('Время окончания должно быть позже времени начала');
            return;
        }
        
        const result = await saveEvent(eventData);
        
        if (result) {
            // Закрываем модальное окно
            const modal = bootstrap.Modal.getInstance(document.getElementById('addEventModal'));
            if (modal) modal.hide();
            
            // Сбрасываем форму
            e.target.reset();
        }
    }
    
    // ОСТАЛЬНЫЕ ФУНКЦИИ
    function updateCategorySelects() {
        // Основной селект категорий
        elements.categorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        elements.bulkCategorySelect.innerHTML = '<option value="">Выберите категорию</option>';
        elements.quickCategory.innerHTML = '<option value="">Выберите категорию</option>';
        
        state.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            option.style.color = category.color;
            elements.categorySelect.appendChild(option.cloneNode(true));
            elements.bulkCategorySelect.appendChild(option.cloneNode(true));
            elements.quickCategory.appendChild(option);
        });
    }
    
    function updateCategoriesList() {
        elements.categoriesList.innerHTML = '';
        
        if (state.categories.length === 0) {
            elements.categoriesList.innerHTML = `
                <div class="text-center text-muted py-3">
                    <i class="bi bi-tags display-6 mb-2"></i>
                    <p>Нет категорий</p>
                    <small>Создайте первую категорию</small>
                </div>
            `;
            return;
        }
        
        state.categories.forEach(category => {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            categoryDiv.style.borderLeftColor = category.color;
            
            categoryDiv.innerHTML = `
                <div class="category-color" style="background-color: ${category.color}"></div>
                <div class="category-info">
                    <div class="category-name">${category.name}</div>
                    ${category.description ? `<small class="text-muted">${category.description}</small>` : ''}
                </div>
                <div class="category-actions">
                    <button class="btn btn-sm btn-outline-secondary edit-category-btn me-1" data-id="${category.id}">
                        <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger delete-category-btn" data-id="${category.id}">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `;
            
            elements.categoriesList.appendChild(categoryDiv);
        });
        
        // Обработчики кнопок категорий
        document.querySelectorAll('.delete-category-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const categoryId = this.dataset.id;
                const category = state.categories.find(c => c.id == categoryId);
                
                if (category) {
                    document.getElementById('deleteMessage').textContent = 
                        `Вы уверены, что хотите удалить категорию "${category.name}"? Все связанные события будут очищены.`;
                    
                    const modal = new bootstrap.Modal(document.getElementById('confirmDeleteModal'));
                    modal.show();
                    
                    document.getElementById('confirmDeleteBtn').onclick = function() {
                        deleteCategory(categoryId);
                        modal.hide();
                    };
                }
            });
        });
    }
    
    function showCategoryModal() {
        initColorPicker();
        const modal = new bootstrap.Modal(document.getElementById('categoryModal'));
        modal.show();
    }
    
    async function createCategory(event) {
        event.preventDefault();
        
        const name = document.getElementById('categoryName').value.trim();
        const color = document.getElementById('selectedColor').value;
        const description = document.getElementById('categoryDescription').value.trim();
        
        if (!name) {
            alert('Введите название категории');
            return;
        }
        
        try {
            const response = await fetch('/api/v1/categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: name,
                    color: color,
                    description: description
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                state.categories.push(result.category);
                updateCategorySelects();
                updateCategoriesList();
                
                document.getElementById('categoryForm').reset();
                bootstrap.Modal.getInstance(document.getElementById('categoryModal')).hide();
                
                alert(`Категория "${name}" создана!`);
            } else {
                alert(result.error || 'Ошибка создания категории');
            }
        } catch (error) {
            console.error('Ошибка создания категории:', error);
            alert('Не удалось создать категорию');
        }
    }
    
    function initTimeSelects() {
        const startTimeSelect = document.getElementById('startTime');
        const endTimeSelect = document.getElementById('endTime');
        
        startTimeSelect.innerHTML = '';
        endTimeSelect.innerHTML = '';
        
        for (let hour = 0; hour < 24; hour++) {
            for (let minute = 0; minute < 60; minute += config.slotMinutes) {
                const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                
                const option1 = document.createElement('option');
                option1.value = time;
                option1.textContent = time;
                startTimeSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = time;
                option2.textContent = time;
                endTimeSelect.appendChild(option2);
            }
        }
    }
    
    function updateWeekRange() {
        const [year, week] = elements.weekPicker.value.split('-W');
        const dates = getWeekDates(year, week);
        
        if (dates.start && dates.end) {
            const startStr = formatDate(dates.start);
            const endStr = formatDate(dates.end);
            elements.weekRange.textContent = `${year} - Неделя ${week} (${startStr} - ${endStr})`;
            
            updateDayHeaders(dates.start);
        }
    }
    
    function getWeekStartDate() {
        const [year, week] = elements.weekPicker.value.split('-W');
        const dates = getWeekDates(year, week);
        return dates.start;
    }
    
    function setCurrentWeek() {
        const today = new Date();
        const year = today.getFullYear();
        const week = getWeekNumber(today);
        elements.weekPicker.value = `${year}-W${week.toString().padStart(2, '0')}`;
        updateWeek();
    }
    
    function prevWeek() {
        const [year, week] = elements.weekPicker.value.split('-W');
        let newWeek = parseInt(week) - 1;
        let newYear = parseInt(year);
        
        if (newWeek < 1) {
            newYear--;
            newWeek = 52;
        }
        
        elements.weekPicker.value = `${newYear}-W${newWeek.toString().padStart(2, '0')}`;
        updateWeek();
    }
    
    function nextWeek() {
        const [year, week] = elements.weekPicker.value.split('-W');
        let newWeek = parseInt(week) + 1;
        let newYear = parseInt(year);
        
        if (newWeek > 52) {
            newYear++;
            newWeek = 1;
        }
        
        elements.weekPicker.value = `${newYear}-W${newWeek.toString().padStart(2, '0')}`;
        updateWeek();
    }
    
    function updateWeek() {
        updateWeekRange();
        loadEvents();
        updateBalanceWheel();
    }
    
    function updateBalanceWheel() {
        const period = elements.wheelPeriod.value;
        const data = calculateBalanceWheelData(period);
        renderBalanceWheel(data);
    }
    
    // Инициализация обработчиков событий
    function initEventHandlers() {
        // Навигация по неделям
        elements.currentWeekBtn.addEventListener('click', setCurrentWeek);
        elements.prevWeekBtn.addEventListener('click', prevWeek);
        elements.nextWeekBtn.addEventListener('click', nextWeek);
        elements.weekPicker.addEventListener('change', updateWeek);
        
        // Кнопки добавления событий
        elements.addPlanBtn.addEventListener('click', () => openAddEventForm('plan'));
        elements.addFactBtn.addEventListener('click', () => openAddEventForm('fact'));
        
        // Форма добавления события
        document.getElementById('addEventForm').addEventListener('submit', handleAddEventForm);
        
        // Категории
        elements.addCategoryBtn.addEventListener('click', showCategoryModal);
        document.getElementById('categoryForm').addEventListener('submit', createCategory);
        
        // Шаблоны (упрощенно)
        elements.saveTemplateBtn.addEventListener('click', () => alert('Функция в разработке'));
        elements.templatesBtn.addEventListener('click', () => alert('Функция в разработке'));
        
        // Быстрые действия
        elements.quickEventBtn.addEventListener('click', showQuickEventModal);
        
        // Установка текущей недели при загрузке
        setCurrentWeek();
    }
    
    function showQuickEventModal() {
        alert('Функция быстрого добавления в разработке');
    }
});
</script>
{% endblock %}
